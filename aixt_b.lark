// This file is part of the Aixt project, https://gitlab.com/fermarsan/aixt-project.git
//
// The MIT License (MIT)
// 
// Copyright (c) 2023 Fernando MartÃ­nez Santa
//
// Based on the V grammar taken from several sources:
//     Abstract Syntax Tree V's documentation:  https://modules.vlang.io/v.ast.html
//     V grammar definition in lark:            https://github.com/Itay2805/Vork/blob/master/v.lark
//     V grammar definition in Antlr-v4:        https://github.com/antlr/grammars-v4/blob/master/v/V.g4

!source_file: (module_clause eos)? ( import_decl eos )* ( top_level_decl eos )*

!module_clause: "module" IDENT

!import_decl:   "import" ( import_spec  )

!import_spec:   ( "." | IDENT )? import_path

!import_path:   IDENT
            |   STRING_LITERAL

!top_level_decl:    declaration
                |   function_decl
                |   method_decl

!declaration:   const_decl
            |   var_decl
            |   struct_decl
        

!const_decl: "const" "(" ( const_spec eos )* ")"

!const_spec: IDENT  "=" expr

!ident_list: IDENT ( "," IDENT )*

!expr_list: expr ( "," expr )*

!function_decl: "fn" IDENT ( function_ | signature )

!function_: signature block

!method_decl: "fn" receiver IDENT ( function_ | signature )

!receiver: parameters

!no_mut_decl: ident_list ( ":=" expr_list )

!var_decl: "mut"? ( no_mut_decl )

!block: "{" stmt_list "}"

!stmt_list: ( stmt eos )*

!stmt:  declaration
    |   simple_stmt
    |   return_stmt
    |   break_stmt
    |   continue_stmt
    |   block
    |   if_stmt
    |   switch_stmt
    |   for_stmt

!simple_stmt:   expr_stmt
            |   inc_dec_stmt
            |   assign_stmt

!expr_stmt: expr

!inc_dec_stmt:  expr ( "++" | "--" )

!assign_stmt:   expr_list ASSIGN_OP expr_list

!return_stmt: "return" expr_list?

!break_stmt:    "break" IDENT?             

!continue_stmt: "continue" IDENT?

!goto_stmt: "goto" IDENT

!if_stmt: "if" (simple_stmt ";")? expr block ( "else" ( if_stmt | block ) )?

!switch_stmt:   expr_switch_stmt

!expr_switch_stmt:  "switch" ( simple_stmt ";" )? expr? "{" expr_case_clause* "}"

!expr_case_clause:  expr_switch_case ":" stmt_list

!expr_switch_case:  "case" expr_list | "default"

!for_stmt:  "for" ( expr | for_clause | in_clause )? block

!for_clause:    simple_stmt? ";" expr? ";" simple_stmt?

!in_clause: expr_list "in" IDENT

!type_: type_name
    |   type_literal

!type_name: "&"? "mut"? IDENT           
        // |   qualified_ident                

!type_literal:  array_type
            |   function_type
            |   interface_type
            |   map_type

!array_type: "[" array_length? "]" element_type

!array_length: expr

!element_type: type_

!interface_type: "interface" IDENT "{" ( method_spec eos )* "}"

!map_type:  "map" "[" type_ "]" element_type

!method_spec:    IDENT parameters result
            |   type_name
            |   IDENT parameters

!function_type: "fn" signature

!signature: parameters result
        |   parameters

!result:    parameters
        |   type_

!parameters: "(" ( parameter_list ","? )? ")"

!parameter_list: parameter_decl ( "," parameter_decl )*

!parameter_decl: ident_list? type_

!operand:   literal
        |   operand_name
        |   method_expr
        |   "(" expr ")"

!literal:   basic_literal
        // |   composite_literal
        |   function_literal
        |   array_literal

!array_literal: "[" expr ("," expr)* "]"

!basic_literal: INTEGER_LITERAL     ->integer_literal
            |   FLOAT_LITERAL       ->  float_literal
            |   CHAR_LITERAL        ->  char_literal 
            |   STRING_LITERAL      ->  string_literal
            |   "true" | "false"    // bool_literal

!operand_name:  IDENT
            // |   qualified_ident

// !qualified_ident:   IDENT "." IDENT

// !composite_literal: literal_type literal_value

!literal_type:  array_type
            |   map_type
            |   type_name

// !literal_value: "{" ( element_list ","? )? "}"

// !element_list: keyed_element (keyed_element)*

// !keyed_element: (key ":")? element

// !key:   IDENT
//     |   expr
//     |   literal_value

!element:   expr
        // |   literal_value

!struct_decl: "struct" IDENT "{" ( field_decl eos )* "}"

!field_decl:    (ident_list type_ | anonymous_field) STRING_LITERAL?
            |   ("pub" ("mut" "mut"?)? | "mut") ":"

!anonymous_field:   type_name

!function_literal:  "fn" function_

!primary_expr:  operand
            |   conversion
            |   primary_expr selector
            |   primary_expr index
	        |   primary_expr arguments
                        

!selector:  "." IDENT

!index: "[" expr "]"

!arguments: "(" ( ( expr_list | type_ ( "," expr_list )? ) ","? )? ")"

!method_expr:   receiver_type "." IDENT

!receiver_type: type_name
            |   "(" receiver_type ")"

!expr:  unary_expr
    |   expr BINARY_OP expr
    
!unary_expr:    primary_expr
            |   UNARY_OP unary_expr

!conversion: type_ "(" expr ")"

!eos:   ";" | NEWLINE                           // end of stmt

TYPE_NAME:  "rune" | "bool" | "string" | NUMERIC_TYPE

NUMERIC_TYPE:   "u8"  | "u16" | "u32" | "u64" | "usize" | "uint"
            |   "i8"  | "i16" | "i32" | "i64" | "isize" | "int"
            |   "f64" | "f32"

ASSIGN_OP:  ("+" | "-" | "|" | "^" | "*" | "/" | "%" | "<<" | ">>" | "&" )? "="
BINARY_OP:  "||" | "&&" | REL_OP | ADD_OP | MUL_OP
REL_OP:     "==" | "!=" | "<" | "<=" | ">" | ">="
ADD_OP.1:   "+" | "-" | "|" | "^"
MUL_OP:     "*" | "/" | "%" | "<<" | ">>" | "&" //| "&^"
UNARY_OP:   "+" | "-" | "!" | "^" | "*" | "&" //| "<-"

FLOAT_LITERAL:      INT EXP | DECIMAL EXP?
INTEGER_LITERAL:    INT | HEX | OCTAL | BIN
DECIMAL:            INT "." INT? | "." INT

STRING_LITERAL: /\'.*\'/
CHAR_LITERAL:   /`.`/
EXP.1:          /[eE][\+-]?[0-9][0-9_]*/        // all numeric literals with "_"
INT:            /[0-9][0-9_]*/                        
HEX.1:          /0x[0-9A-Fa-f][0-9A-Fa-f_]*/
OCTAL.1:        /0o[0-7][0-7_]*/        
BIN.1:          /0b[01][01_]*/                


%import common.CNAME    ->  IDENT
%import common (CPP_COMMENT, C_COMMENT, WS_INLINE, NEWLINE)

%ignore WS_INLINE 
%ignore CPP_COMMENT
%ignore C_COMMENT


// type _expr = AnonFn
// 	| Array_decompose
// 	| Array_init
// 	| AsCast
// 	| Assoc
// 	| At_expr
// 	                        | BOOL_LITERAL
// 	| CTempVar
// 	| Call_expr
// 	| Cast_expr
// 	| Chan_init
// 	                        | CHAR_LITERAL
// 	                        | Comment (CPP_COMMENT, CPP_COMMENT)
// 	| ComptimeCall
// 	| ComptimeSelector
// 	| Comptime_type
// 	| Concat_expr
// 	| Dump_expr
// 	| Empty_expr
// 	| EnumVal
// 	                        | FLOAT_LITERAL
// 	| Go_expr
// 	                        | IDENT      
// 	| If_expr
// 	| IfGuard_expr
// 	| Index_expr
// 	| Infix_expr
// 	                        | INTEGER_LITERAL
// 	| IsRef_type
// 	| Likely
// 	| Lock_expr
// 	| Map_init
// 	| Match_expr
// 	| Nil
// 	| NodeError
// 	| None
// 	| OffsetOf
// 	| Or_expr
// 	| Par_expr
// 	| Postfix_expr
// 	| Prefix_expr
// 	| Range_expr
// 	| Select_expr
// 	| Selector_expr
// 	| SizeOf
// 	| Sql_expr
// 	| StringInter_literaleral
// 	                        | STRING_LITERAL
// 	| Struct_init
// 	| _typeNode
// 	| _typeOf
// 	| Unsafe_expr

// type _stmt = Asm_stmt
// 	| Assert_stmt
// 	                        | assign_stmt
// 	                        | block
// 	| Branch_stmt
// 	| ComptimeFor
// 	                        | const_decl
// 	| Defer_stmt
// 	| Empty_stmt
// 	| Enum_decl
// 	| _expr_stmt
// 	| Fn_decl
// 	                        | for_c_stmt    (for_clause)
// 	                        | for_in_stmt   (in_clause)
// 	                        | for_stmt
// 	| Global_decl
// 	| GotoLabel
// 	| Goto_stmt
// 	| Hash_stmt
// 	                        | import_decl
// 	| Interface_decl
// 	                        | module_clause
// 	| NodeError
// 	                        | return_stmt
// 	| Sql_stmt
// 	                        | struct_decl
// 	| _type_decl