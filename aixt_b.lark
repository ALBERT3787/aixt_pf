// This file is part of the Aixt project, https://gitlab.com/fermarsan/aixt-project.git
//
// The MIT License (MIT)
// 
// Copyright (c) 2023 Fernando MartÃ­nez Santa
//
// Based on the V grammar taken from several sources:
//     Abstract Syntax Tree V's documentation:  https://modules.vlang.io/v.ast.html
//     V grammar definition in lark:            https://github.com/Itay2805/Vork/blob/master/v.lark
//     V grammar definition in Antlr-v4:        https://github.com/antlr/grammars-v4/blob/master/v/V.g4

!source_file: (module_clause eos)? ( import_decl eos )* ( top_level_decl eos )* EOF

!module_clause: "module" IDENT

!import_decl:   "import" ( import_spec  )

!import_spec:   ( "." | IDENT )? import_path

!import_path:   IDENT
            |   STRING_LIT

!top_level_decl:    declaration
                |   function_decl
                |   method_decl

!declaration:   const_decl
            |   var_decl
            |   struct_decl

!const_decl: 'const' "(" ( const_spec eos )* ")"

!const_spec: IDENT  '=' expr

!ident_list: IDENT ( "," IDENT )*

!expr_list: expr ( "," expr )*

!function_decl: "fn" IDENT ( function_ | signature )

!function_: signature block

!method_decl: "fn" receiver IDENT ( function_ | signature )

!receiver: parameters

!no_mut_decl: ident_list ( ':=' expr_list )var_decl: "mut"? ( no_mut_decl )

!block: "{" stmt_list "}"

!stmt_list: ( stmt eos )*

!stmt:  declaration
    |   simple_stmt
    |   return_stmt
    |   break_stmt
    |   continue_stmt
    |   block
    |   if_stmt
    |   switch_stmt
    |   for_stmt

!simple_stmt:   expr_stmt
            |   inc_dec_stmt
            |   assignment

!expr_stmt: expr
!inc_dec_stmt:  expr ( "++" | "--" )
!assignment:    expr_list ASSIGN_OP expr_list

!return_stmt: "return" expr_list?

!break_stmt:    "break" IDENT?             

!continue_stmt: "continue" IDENT?:      

!goto_stmt: "goto" IDENT

!if_stmt: "if" (simple_stmt ";")? expr block ( 'else' ( if_stmt | block ) )?

!switch_stmt:   expr_switch_stmt

!expr_switch_stmt:  "switch" ( simple_stmt ";" )? expr? "{" expr_case_clause* "}"

!expr_case_clause:  expr_switch_case ":" stmt_list

!expr_switch_case:  "case" expr_list | "default"

!for_stmt:  "for" ( expr | for_clause | in_clause )? block

!for_clause:    simple_stmt? ";" expr? ";" simple_stmt?

!in_clause: expr_list "in" IDENT

!type_: type_name
    |   type_literal

!type_name: "&"? "mut"? IDENT           
        |   qualified_ident                

!type_literal:  array_type
            |   function_type
            |   interface_type
            |   map_type

!array_type: "[" array_length? "]" element_type

!array_length: expr

!element_type: type_

!interface_type: "interface" IDENT "{" ( method_spec eos )* "}"

!map_type:  "map" "[" type_ "]" element_type

!method_spec:    IDENT parameters result
            |   type_name
            |   IDENT parameters

!function_type: "fn" signature

!signature: parameters result
        |   parameters

!result:    parameters
        |   type_

!parameters: "(" ( parameter_list ","? )? ")"

!parameter_list: parameter_decl ( "," parameter_decl )*

!parameter_decl: ident_list? type_

!operand:   literal
        |   operand_name
        |   method_expr
        |   "(" expr ")"

!literal:   basic_literal
        |   composite_literal
        |   function_literal
        |   array_literal

!array_literal: "[" expr ("," expr)* "]"

!basic_literal: integer_literal
            |   FLOAT           ->  float_literal
            |   CHAR            ->  char_literal 
            |   STRING          ->  string_literal
            |   "true" | "false"

!operand_name:  IDENT
            |   qualified_ident

!qualified_ident:   IDENT "." IDENT

!composite_literal: literal_type literal_value

!literal_type:  array_type
            |   map_type
            |   type_name

!literal_value: "{" ( element_list ","? )? "}"

!element_list: keyed_element (keyed_element)*

!keyed_element: (key ":")? element

!key:   IDENT
    |   expr
    |   literal_value

!element:   expr
        |   literal_value

!struct_decl: "struct" IDENT "{" ( field_decl eos )* "}"

!field_decl:    (ident_list type_ | anonymous_field) STRING_LIT?
            |   ("pub" ("mut" "mut"?)? | "mut") ":"

!anonymous_field:   type_name

!function_literal: "fn" function_

!primary_expr:  operand
            |   conversion
            |   primary_expr selector
            |   primary_expr index
	        |   primary_expr arguments

!selector:  "." IDENT

!index: "[" expr "]"

!arguments: "(" ( ( expr_list | type_ ( "," expr_list )? ) ","? )? ")"

!method_expr:   receiver_type "." IDENT

!receiver_type: type_name
            |   "(" receiver_type ")"

!expr:  unary_expr
    |   expr BINARY_OP expr
    
!unary_expr:    primary_expr
            |   UNARY_OP unary_expr

!conversion: type_ "(" expr ")"

!integer_literal:   INT | HEX | OCTAL | BIN     

!eos:   ";" | NEWLINE                           // end of stmt

TYPE_NAME:  "rune" | "bool" | "string" | NUMERIC_TYPE

NUMERIC_TYPE:   "u8"  | "u16" | "u32" | "u64" | "usize" | "uint"
            |   "i8"  | "i16" | "i32" | "i64" | "isize" | "int"
            |   "f64" | "f32"

ASSIGN_OP:  ("+" | "-" | "|" | "^" | "*" | "/" | "%" | "<<" | ">>" | "&" )? "="
BINARY_OP:  "||" | "&&" | REL_OP | ADD_OP | MUL_OP
REL_OP:     "==" | "!=" | "<" | "<=" | ">" | ">="
ADD_OP.1:   "+" | "-" | "|" | "^"
MUL_OP:     "*" | "/" | "%" | "<<" | ">>" | "&" | "&^"
UNARY_OP:   "+" | "-" | "!" | "^" | "*" | "&" | "<-"

FLOAT:      INT EXP | DECIMAL EXP?
DECIMAL:    INT "." INT? | "." INT

STRING:     /\'.*\'/
CHAR:       /`.`/
EXP.1:      /[eE][\+-]?[0-9][0-9_]*/            // all numeric literals with "_"
INT:        /[0-9][0-9_]*/                        
HEX.1:      /0x[0-9A-Fa-f][0-9A-Fa-f_]*/
OCTAL.1:    /0o[0-7][0-7_]*/        
BIN.1:      /0b[01][01_]*/                


%import common.CNAME    ->  IDENT
%import common (CPP_COMMENT, C_COMMENT, WS_INLINE, NEWLINE)

%ignore WS_INLINE 
%ignore CPP_COMMENT
%ignore C_COMMENT


// type __expr = AnonFn
// 	| Array_decompose
// 	| Array_init
// 	| AsCast
// 	| Assoc
// 	| At__expr
// 	                        | bool_literal (BOOL)
// 	| CTempVar
// 	| Call__expr
// 	| Cast__expr
// 	| Chan_init
// 	                        | char_literal
// 	                        | Comment
// 	| ComptimeCall
// 	| ComptimeSelector
// 	| Comptime_type
// 	| Concat__expr
// 	| Dump__expr
// 	| Empty__expr
// 	| EnumVal
// 	                        | float_literal
// 	| Go__expr
// 	                        | IDENT      
// 	| If__expr
// 	| IfGuard__expr
// 	| Index__expr
// 	| Infix__expr
// 	                        | integer_literal
// 	| IsRef_type
// 	| Likely
// 	| Lock__expr
// 	| Map_init
// 	| Match__expr
// 	| Nil
// 	| NodeError
// 	| None
// 	| OffsetOf
// 	| Or__expr
// 	| Par__expr
// 	| Postfix__expr
// 	| Prefix__expr
// 	| Range__expr
// 	| Select__expr
// 	| Selector__expr
// 	| SizeOf
// 	| Sql__expr
// 	| StringInter_literaleral
// 	                        | string_literal
// 	| Struct_init
// 	| _typeNode
// 	| _typeOf
// 	| Unsafe__expr

// type _stmt = Asm_stmt
// 	| Assert_stmt
// 	                        | assign_stmt
// 	| Block
// 	| Branch_stmt
// 	| ComptimeFor
// 	| Const_decl
// 	| Defer_stmt
// 	| Empty_stmt
// 	| Enum_decl
// 	| __expr_stmt
// 	| Fn_decl
// 	| ForC_stmt
// 	| ForIn_stmt
// 	| For_stmt
// 	| Global_decl
// 	| GotoLabel
// 	| Goto_stmt
// 	| Hash_stmt
// 	| Import
// 	| Interface_decl
// 	| Module
// 	| NodeError
// 	| Return
// 	| Sql_stmt
// 	| Struct_decl
// 	| _type_decl