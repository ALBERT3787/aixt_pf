// This file is part of the Aixt project, https://gitlab.com/fermarsan/aixt-project.git
//
// The MIT License (MIT)
// 
// Copyright (c) 2023 Fernando MartÃ­nez Santa
//
// Based on the V grammar taken from several sources:
//     Abstract Syntax Tree V's documentation:  https://modules.vlang.io/v.ast.html
//     V grammar definition in lark:            https://github.com/Itay2805/Vork/blob/master/v.lark
//     V grammar definition in Antlr-v4:        https://github.com/antlr/grammars-v4/blob/master/v/V.g4


// start: _module_item*

// _module_item: fn_decl
//             | method_decl
//             | struct_decl
//             | module_decl
//             | import_decl
//             | interop_fn_decl
//             | const_decl

// // Misc
// module_decl: "module" IDENT ("." IDENT)*
// import_decl: "import" IDENT ("." IDENT)*

// // Function declaration
// fn_decl: maybe_pub "fn" IDENT "(" fn_params ")" fn_return stmt_list
// interop_fn_decl: "fn" IDENT "." IDENT "(" fn_params ")" fn_return
// fn_params: [fn_param ("," fn_param)*]
// fn_param: IDENT maybe_mut type_decl | IDENT
// fn_return: [type_decl | "(" type_decl ("," type_decl)+ ")"]

// // Struct declaration
// struct_decl: maybe_pub "struct" IDENT "{" embedded_struct_field struct_fields "}"
// struct_fields: (struct_field | struct_access_mod ":")*
// struct_field: IDENT type_decl
// !struct_access_mod: "mut"
//                   | "pub"
//                   | "pub" "mut"
//                   | "pub" "mut" "mut"
// embedded_struct_field: (maybe_mut IDENT)?

// // Method declaration
// method_decl: maybe_pub "fn" "(" IDENT maybe_mut type_decl ")" IDENT "(" fn_params ")" fn_return stmt_list

// // const declaration
// const_decl: "const" "(" (const_item)+ ")"
//           | "const" const_item
// const_item: IDENT "=" _expr


// ///////////////////////////////////////////////////
// // Statements
// ///////////////////////////////////////////////////

// ?stmt: "return" [_expr ("," _expr)*] -> stmt_return
//      | "assert" _expr -> stmt_assert
//      | "for" IDENT "in" _expr stmt_list -> stmt_foreach
//      | "for" IDENT "," IDENT "in" _expr stmt_list -> stmt_foreach_indexed
//      | "for" stmt_list-> stmt_forever
//      | "for" (maybe_var_decl|stmt_assignment) ";" _expr ";" (_expr | stmt_assignment) stmt_list -> stmt_for
//      | "break" -> stmt_break
//      | "continue" -> stmt_continue
//      | stmt_var_decl
//      | stmt_assignment
//      | stmt_if
//      | (expr_fn_call) -> stmt_expr

// stmt_var_decl: var_decl_vars ":=" _expr
// !maybe_var_decl: stmt_var_decl?

?stmt_assignment: (IDENT|expr_member_access|expr_index) ASSIGN_OP _expr -> stmt_assign

// stmt_if: "if" _expr stmt_list (stmt_else |)
// ?stmt_else: "else" stmt_list -> stmt_else
//           | "else" stmt_if -> stmt_else_if

// var_decl: maybe_mut IDENT
// var_decl_vars: var_decl ("," var_decl)*

// stmt_list: "{" stmt* "}"

// _expr: expr_logical_or

// ?expr_logical_or: expr_logical_and (OP_LOG_OR expr_logical_and)* -> expr_binary
// ?expr_logical_and: expr_bitwise_or (OP_LOG_AND expr_bitwise_or)* -> expr_binary
// ?expr_bitwise_or: expr_bitwise_xor (OP_BW_OR expr_bitwise_xor)* -> expr_binary
// ?expr_bitwise_xor: expr_bitwise_and (OP_BW_XOR expr_bitwise_and)* -> expr_binary
// ?expr_bitwise_and: expr_equality (OP_BW_AND expr_equality)* -> expr_binary
// ?expr_equality: expr_relational (OP_EQ expr_relational)* -> expr_binary
// ?expr_relational: expr_shift (OP_REL expr_shift)* -> expr_binary
// ?expr_shift: expr_additive (OP_SHIFT expr_additive)* -> expr_binary
// ?expr_additive: expr_multiplicative (OP_ADD expr_multiplicative)* -> expr_binary
// ?expr_multiplicative: expr_unary (OP_MUL expr_unary)* -> expr_binary

?expr_unary: expr_fix
//            | OP_UNARY expr_fix -> expr_unary

?expr_fix: expr_others
//          | OP_PREFIX (expr_member_access|expr_index|IDENT) -> expr_prefix
//          | (expr_member_access|expr_index|IDENT) OP_POSTFIX -> expr_postfix

?expr_others: expr_literals
//             | expr_member_access
//             | expr_index
//             | expr_fn_call

// expr_fn_call: _expr "(" (maybe_mut _expr ("," maybe_mut _expr)*)? ")"
// expr_member_access: _expr "." IDENT
// expr_index: _expr "[" _expr "]"

?expr_literals: "(" _expr ")"
            |   "none" -> const_none
            |   BOOL_LITERAL
            |   STRING_LITERAL
            |   INTEGER_LITERAL
            |   FLOAT_LITERAL
            |   IDENT
//           | struct_literal
//           | struct_literal_named
//           | array_literal
//           | array_literal_uninit

// struct_literal: maybe_ref module_path_ident "{" (_expr ("," _expr )*)? "}"
// struct_literal_named: maybe_ref module_path_ident "{" struct_literal_named_item (struct_literal_named_item)* "}"
// struct_literal_named_item: IDENT ":" _expr

// // array literal
// array_literal: "[" _expr ("," _expr)* "]"
// array_literal_uninit: "[" _expr "]" type_decl


// module_path_ident: IDENT ("." IDENT)*

?type_decl: type_ident
//           | type_array
//           | type_map
//           | type_ref
//           | type_opt

// type_array: "[" "]" type_decl
// type_map: "map" "[" type_decl "]" type_decl
// type_ref: "&" type_decl
// type_opt: "?" type_decl
!type_ident: IDENT

!maybe_pub: "pub"?
!maybe_mut: "mut"?
!maybe_ref: "&"?

ASSIGN_OP:  ("+" | "-" | "|" | "^" | "*" | "/" | "%" | "<<" | ">>" | "&" )? "="
BINARY_OP:  "||" | "&&" | REL_OP | ADD_OP | MUL_OP
REL_OP:     "==" | "!=" | "<" | "<=" | ">" | ">="
ADD_OP.1:   "+" | "-" | "|" | "^"
MUL_OP:     "*" | "/" | "%" | "<<" | ">>" | "&" | "&^"
UNARY_OP:   "+" | "-" | "!" | "^" | "*" | "&" | "<-"

INTEGER_LITERAL: INT | HEX | OCTAL | BIN
FLOAT_LITERAL:      INT EXP | DECIMAL EXP?
DECIMAL:    INT "." INT? | "." INT

BOOL_LITERAL:   "true" | "false"
STRING_LITERAL: /\'.*\'/
CHAR_LITERAL:   /`.`/
EXP.1:          /[eE][\+-]?[0-9][0-9_]*/            // all numeric literals with "_"
INT:            /[0-9][0-9_]*/                        
HEX.1:          /0x[0-9A-Fa-f][0-9A-Fa-f_]*/
OCTAL.1:        /0o[0-7][0-7_]*/        
BIN.1:          /0b[01][01_]*/                

%import common.CNAME    ->  IDENT
%import common (CPP_COMMENT, C_COMMENT, WS_INLINE, NEWLINE)

%ignore WS_INLINE 
%ignore CPP_COMMENT
%ignore C_COMMENT

// type _expr = AnonFn
// 	| ArrayDecompose
// 	| Array_init
// 	| AsCast
// 	| Assoc
// 	| At_expr
// 	                        | BOOL_LITERAL
// 	| CTempVar
// 	| Call_expr
// 	| Cast_expr
// 	| Chan_init
// 	                        | CHAR_LITERAL
// 	                        | Comment (C_COMMENT, CPP_COMMENT
// 	| ComptimeCall
// 	| ComptimeSelector
// 	| Comptime_type
// 	| Concat_expr
// 	| Dump_expr
// 	| Empty_expr
// 	| EnumVal
// 	                        | FLOAT_LITERAL
// 	| Go_expr
// 	                        | IDENT      
// 	| If_expr
// 	| IfGuard_expr
// 	| Index_expr
// 	| Infix_expr
// 	                        | INTEGER_LITERAL
// 	| IsRef_type
// 	| Likely
// 	| Lock_expr
// 	| Map_init
// 	| Match_expr
// 	| Nil
// 	| NodeError
// 	| None
// 	| OffsetOf
// 	| Or_expr
// 	| Par_expr
// 	| Postfix_expr
// 	| Prefix_expr
// 	| Range_expr
// 	| Select_expr
// 	| Selector_expr
// 	| SizeOf
// 	| Sql_expr
// 	| StringInter_literaleral
// 	                        | STRING_LITERAL
// 	| Struct_init
// 	| _typeNode
// 	| _typeOf
// 	| Unsafe_expr

// type _stmt = Asm_stmt
// 	| Assert_stmt
// 	                        | assign_stmt
// 	| Block
// 	| Branch_stmt
// 	| ComptimeFor
// 	| Const_decl
// 	| Defer_stmt
// 	| Empty_stmt
// 	| Enum_decl
// 	| _expr_stmt
// 	| Fn_decl
// 	| ForC_stmt
// 	| ForIn_stmt
// 	| For_stmt
// 	| Global_decl
// 	| GotoLabel
// 	| Goto_stmt
// 	| Hash_stmt
// 	| Import
// 	| Interface_decl
// 	| Module
// 	| NodeError
// 	| Return
// 	| Sql_stmt
// 	| Struct_decl
// 	| _type_decl